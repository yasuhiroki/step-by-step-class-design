# Step2. 直交性

## Introduction

　直交性という単語を初めて知ったのは、達人プログラマーを読んだ時だった。その時の私は、直交性とはつまり、システムやコンポーネント間を独立させることで、いわゆるモジュール結合度を下げることだと読み取ったが、直交性という単語が自分の体に染み込むことはなかった。それよりもDRYやYAGNIやKISSの方が頭に残りやすかったのだが、それはおそらく、後者はメッセージがそのまま名前になっているが、直交性は、ほんの少しだが数学的要素が入っていて、抽象的な表現だからだろう。  
　しかし、改めて直交性について考えてみると、むしろ数学的要素が入っている分、こちらの方が私には向いていると分かった。直交性とは、X軸とY軸があったとして、Xが増減してもYには無関係であることを指す。このX軸とY軸に何を当てはめるのかさえ理解すれば、それだけで自分の取るべき道を明確に示すようになる。  
　Xを増やしたらYが減った、だからこれは直交ではないのでだめだ。そう考えれば良いのだからシンプルである。  
　本項では、直交性について具体的なX軸とY軸を当てはめて考えてみる。

## クラスの直交性

　クラスの直交性は大きく分けると二つに分けられる。あるクラス自身の直交性と、複数のクラス間の直交性だ。

### クラス自身の直交性

　ここでの直交性は、あるクラス1つに絞って考える。  
　例えば、`X = methodA` `Y = methodB` と考えた場合、`methodA` の仕様が変わった時 `methodB` も変更になる場合は直交性に欠けている。

```ruby
class Sample

  def methodA(val)
    "value: #{val}"
  end

  def methodB(val)
    val = methodA(val)
    "additinal with #{val}"
  end

end

sample = Sample.new
puts sample.methodA("hoge")
puts sample.methodB("hoge")
```

　これは、次のように実装すれば直交する。

```ruby
class Sample

  def methodA(val)
    "value: #{val}"
  end

  def methodB(val)
    "additinal with #{val}"
  end

end

sample = Sample.new
puts sample.methodA("hoge")
puts sample.methodB(sample.methodA("hoge"))
```

　しかし私は度々、前者の方が便利だと思ってしまうことがある。`methodB` の中で `methodA` を呼ぶことで、呼び出し側がいちいち `methodA` を呼ぶ必要がなくなるので楽だ、と感じてしまうのだが、それは勘違いだった。このクラスを実装している時の私は、 `methodA` と `methodB` の関係を 100% 完璧に把握しているので、`methodB` の中で `methodA` を使うことが楽で素晴らしい選択だと錯覚してしまう。  
　だが、しばらく経って `methodA` と `methodB` の関係を 50% くらいしか覚えていない日が来ると、`methodB` が `methodA` を使っていたかどうかうろ覚えで、このSampleクラスの実装を確認することになる。厄介なことに、その作業は簡単だ。`vim sample.rb` とするだけなせいで、私は自分の愚かな選択に気がつかない。しかし、どんな実装だったか確認する、という作業がすでに DRY に反しているのだ。作業の二重化をしてしまっている。私はこの時点で、コードに潜む嫌な臭いに気付くべきであった。  
　さらに時が経って、Sampleクラスは自分が実装したものだと忘れた頃に、 `methodA` の実装を変更したくなった。`value => #{val}` という文字列に変えたいのかもしれない。その頃には、私は `methodB` の存在を忘れているので `methodA` の実装を変更し commit してテストを走らせるだろう。たかが小さな変更だ、テストが落ちるとは毛頭思っていない。しかしテストが落ちる。`methodB` のテストが通らない。`methodB` を使用する別のクラスのテストも落ちる。なぜだ！ 私は `methodA` しか変更していないのに！  
　もし私が自分を律して後者の実装を選択できていれば、`methodA` を変更した時に落ちるテストは、 `methodA` を使っている部分に限られる。テストが落ちる部分を探すのも、理由を知るのも簡単だ。`methodA` を変更したから `methodA` を使っている部分を修正しなければならない。そこに `methodB` は出てこない。  
　あるクラス自身の直交性を保つとは、そのクラスが持つインターフェースをなるべく疎結合にするということだ。もちろん、似た処理の共通化や、繰り返し実行される処理をまとめるために、メソッドから別のメソッドを呼ぶこともあるだろう。しかし、それは最小限にすべきだ。もしその共通化が増えてきたのだとしたら、それらは別のクラスに追い出してしまうべきだろう。

### 複数のクラス間の直交性

　複数のクラス間の直交性も、結局はクラス単体の直交性と同じ考えだ。  
　例えば `X = classA` `Y = classB` と考えた場合、 `classA` の仕様が変わった時 `classB` も変更になる場合は直交性に欠けている。

　TBD

### 参考

- 達人プログラマー, 直交性
- 達人プログラマー, 結合度の最小化とデメテルの法則

