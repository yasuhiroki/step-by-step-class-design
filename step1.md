# Step1. DRYの原則

## Introduction

　プログラミングには、その歴史の中で生まれた教訓があり、中には名前がついて原則として語り継がれている。アルファベットの省略だったり、文章だったり、人名を冠にすることもある原則たちは、迷える子プログラマー達に歩むべき道を示している。私はその原則を目にしたことがあるし、いくつかは覚えているが、身についているかというと難しい。  
　原則を覚えることと原則を理解することの間には、大きな隔たりがある。  
　例えばDRYに反している、と口にするのは簡単だが、ではDRYに反しない実装にする手段はどれだけあるのか私は説明できない。原則は知ることが目的ではなく、自分がより良くコーディングするための判断材料に活用するのだ。  
　本項ではDRYの原則について考える。

## DRY \(Don't Repeat Yourself\)

　DRYは分かりやすいが、勘違いもしやすい。  
　直訳すれば、同じことを繰り返すな、という意味だが、同じコードを重複するな、という意味ではない。開発全体の中で情報を重複するな、という、コードよりもずっと広い範囲を指す。  
　達人プログラマーでは、二重化が発生する原因とその対策について述べている。その中から、特に気になった点をいくつかピックアップする。

### コードとコメント

　コードと、コードに対するコメントは、両方とも同じ情報を指している点では二重化だと思えるかもしれない。しかしそれは、コードから読み取れる情報と同じことをコメントに書いている場合だ。コードには書かれていない情報（例えば「この数までなら画質に影響ないと判断」など）があれば、コードとコメントを合わせることでより正確な情報となる。  
　一方で、ついつい書きがちなのが補助的なコメントだ。読み辛いコード、いい名前が思いつかなかったメソッド名に対して、言い訳めいたコメントを書くことである。リーダブルコードでは、 `優れたコード > ひどいコード + 優れたコメント` と表現しているが、DRYの観点で言うと、 `ひどいコード + 優れたコード` は情報の二重化であり、原則に違反している。  
　ただし、現実としては、自分の力不足により、優れたコードにできないことが多い。そのため私は、先ほどのリーダブルコードに加えて、`優れたコード > ひどいコード + 優れたコメント >>> ひどいコード + 言い訳コメント >>>>>>>>>> ひどいコード` だと考えるようにして、最低でも `ひどいコード + 優れたコード` が自分の品質となるように意識している。

### コメントとドキュメントとテスト

　仕様についてのドキュメントと、仕様通りに実装できているか確認するテストコードもまた、仕様という情報の二重化だ。であれば、どちらかを作成してから、もう一方を自動生成できる方が効率的だろう。具体的には、コード上にコメントでドキュメントを記述するようにするが、コメントには文章だけでなくテストも記述しておく。コメントからドキュメントを自動生成し、同時にテストも実行できるようにするのだ。これは Elixir が Doctests として標準機能として備えている。

## DRYを守るために

　DRYを守るということは、同じ情報を二重に管理しないようにする、ということだ。しかし、同じ情報という感覚が難しい。例えば達人プログラマーでは次のようなコードから、同じ情報を見落としてしまって生じたDRYの違反を、不慮の二重化と表現して言及している。なお、原著のコードはJavaだが、私はRubyが好きなのでRubyに置き換えている。

```ruby
class Line
  attr_accessor :start, :end, :length
end
```

　このLineクラスは、 `start` `end` `length` というプロパティを持っている。`length` は `start` と `end` の間の長さを保持ししている。何が二重化しているかというと、次のような実装を考えると分かりやすい。


```ruby
class Line
  attr_accessor :start, :end, :length
end

line = Line.new
line.start  = 0
line.end    = 100
line.length = (line.start - line.end).abs
```

　`length = (start - end).abs` の部分が二重化している。`start` か `end` を更新したら `length` も更新しなければならない。  
　この場合は、次のように修正すれば良い。

```ruby
class Line
  attr_accessor :start, :end

  def length
    return (@start - @end).abs
  end
end

line = Line.new
line.start  = 0
line.end    = 100
```

### 参考

- 達人プログラマー, 二重化の過ち
- リーダブルコード, コメントすべきことを知る
- [あなたはDRY原則を誤認している？](http://qiita.com/yatmsu/items/b4a84c4ae78fd67a364c)
- [Docs, tests and with - Elixir](https://elixir-lang.org/getting-started/mix-otp/docs-tests-and-with.html)

